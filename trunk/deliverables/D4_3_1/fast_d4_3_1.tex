\documentclass{fast_latex}
% yay! We can use any kind of funky diacritic:
\usepackage[utf8]{inputenc}

\usepackage{lastpage}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage[pdfborder={0 0 0}]{hyperref}		% turn on when latex is used (not miktec)
\usepackage{url} % LEO: urls \url{}
\usepackage{verbatim} % code and comment
\usepackage{longtable}
\usepackage{xspace}   % whitespace after a macro if no punctuation after the macro
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{longtable}
\usepackage{array}
\usepackage{amssymb} 
\parindent0pt

% This is useful for switching in-line comments on and off!
\usepackage{ifthen}
\newboolean{showcomments}
\setboolean{showcomments}{true}
\ifthenelse{\boolean{showcomments}}
{
	\definecolor{Red}{rgb}{1,0,0}
	\newcommand{\note}[1]{\begin{scriptsize}{{\textsf{\textbf{{\textcolor{Red}{[[#1]]}}}}}}\end{scriptsize}}
	\definecolor{Orange}{rgb}{1,0.5,0}
	\newcommand{\todo}[1]{\textsf{\textbf{\textcolor{Orange}{[[TODO: #1]]}}}}
    \definecolor{Green}{rgb}{0,1,0}
    \newcommand{\commentreply}[1]{\begin{scriptsize}{\textsf{\textbf{\textcolor{Green}{[[#1]]}}}}\end{scriptsize}}
} {
	\newcommand{\note}[1]{\textbf{}}
	\newcommand{\todo}[1]{}
    \newcommand{\commentreply}[1]{}
}



\newcommand\deliverableNumber{D4.3.1}
\newcommand\deliverableTitle{Mechanisms for Gadget-Service Connections and Gadget Functionality}
\newcommand\deliverableTitleShort{Mechanisms for Gadget-Service Connections}
\newcommand\workpackageNumber{4}
\newcommand\workpackageTitle{Visual composition of screen-flow resources and interoperability with back-end Web Services}
\newcommand\authorOne{Ismael Rivera, NUIG}
\newcommand\authorTwo{Albert Z\"undorf, UniKassel}
\newcommand\authorThree{Author 3}
\newcommand\authorFour{Author 4}
\newtheorem{example}{\emph{Example}}

\begin{document}
% explicit hyphenations
%\hyphenation{RDF-Re-po-si-to-ry}
%\hyphenation{name-space}

%\fontfamily{tahoma}\selectfont
\def\note#1{\marginpar{\footnotesize#1}} % use this to show the notes in the document
%\def\note#1{} % use this to hide the notes



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TITLE PAGES 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{empty}

% \pagenumbering{roman}

\begin{flushright}
	\includegraphics[width=3cm]{images/FP7_logo}
\end{flushright}

\vspace{1cm}

%\begin{minipage}[p]{15cm}
	\begin{center}
		\includegraphics{images/FAST_logo}\\
		\vspace{1cm}
		{\LARGE{\sffamily \emph{FAST AND ADVANCED STORYBOARD TOOLS}}}\\
		\vspace{0.5cm}
		{\LARGE \sffamily \emph{FP7-ICT-2007-1-216048}}\\
		\vspace{0.5cm}
		{\LARGE \sffamily \emph{http://fast.morfeo-project.eu}}\\
		\vspace{4cm}
		{\LARGE \sffamily \textbf{Deliverable \deliverableNumber}}\\
		\vspace{0.5cm}
		{\LARGE \sffamily \textbf{\deliverableTitle}}\\
		\vspace{2cm}
		{\large \sffamily \authorOne}\\
		\vspace{0.2cm}
		{\large \sffamily \authorTwo}\\
		\vspace{0.5cm}
		\vfill
		{\large \sffamily Date: 19/02/2010}\\
		\vspace{1cm}
		{\sffamily FAST is partially funded by the E.C. (grant code: FP7-ICT-2007-1-216048).}
		
	\end{center}
%\end{minipage}


\clearpage
%%%%%%%%%%%%%%
% NEXT PAGES %
%%%%%%%%%%%%%%
\pagestyle{scrheadings}

\lohead{\includegraphics[width=4cm]{images/FAST_logo_transparent}}
%\cohead{\small\textcolor{fast@lightgrey}{\deliverableTitle}}
%\rohead{\small{\today}}
%\lofoot{\small\textcolor{fast@lightgrey}{Task Force Ontologies}}
% \cofoot{\small{FAST 216048 --- \deliverableTitleShort}}
% \rofoot{\small{\thepage}}
\cofoot{\small{FAST $\bullet$ 216048 $\bullet$ \deliverableTitleShort{} $\bullet$ Page \thepage\ of \pageref{LastPage}}}

\newpage
%
%\section*{Authors}
%\authorOne \\
%%\authorTwo \\
%%\authorThree\\
%%\authorFour\\
%
%
%\vfill
%%\section*{Project Co-ordinator}
%%\hspace*{-2,5cm}\begin{minipage}[p]{14cm}
%%Dr. Ansgar Bernardi \\
%%German Research Center for Artificial Intelligence (DFKI) GmbH \\
%%Trippstadter Strasse 122 \\
%%D 67663 Kaiserslautern \\
%%Germany \\
%%Email: bernardi@dfki.uni-kl.de, phone: +49 631 205 3582, fax: +49 631 205 4910 \\
%%\end{minipage}
%
%
%\section*{Partners}
%Telef\'onica Investigaci\'on y Desarrollo (Telef\'onica I+D), Spain \\
%National University of Ireland, Galway (NUIG), Republic of Ireland \\
%Kassel University, Germany \\
%Cyntelix Corporation, Republic of Ireland \\
%SAP AG, Germany \\
%Universidad Polit\'ecnica de Madrid (UPM), Spain
%
%
%\vspace{0.3cm}
%\begin{footnotesize}
%Copyright: FAST Consortium 2009\\
%\end{footnotesize}

%\clearpage


\section*{Version History}

\begin{small}
\begin{tabular}{|l|l|l|p{7.5cm}|}
\hline
\rowcolor{fast@lightgrey}\textcolor{white}{\textbf{Rev. No.}} &
                            \textcolor{white}{\textbf{Date}} &
                            \textcolor{white}{\textbf{Author (Partner)}} &
							\textcolor{white}{\textbf{Change description}}\\ \hline
1.0 & 26.02.2010 & Ismael Rivera (NUIG) & Final version ready for external review \\ \hline
\end{tabular}
\end{small}

\color{black}

\vfill
%{\bf Explanations of abbreviations on front page}\\
%\\
%%Nature \\
%R: Report \\
%P: Prototype \\
%R/P: Report and Prototype \\
%O: Other \\
% \\
%Dissemination level \\
%PU: Public \\
%PP: Restricted to other FP6 participants \\
%RE: Restricted to specified group \\
%CO: Confidential, only for NEPOMUK partners \\

\newpage

%%%%%%%%%%%%%%%%%%%%%
% Executive Summary %
%%%%%%%%%%%%%%%%%%%%%

\clearpage

\section*{Executive Summary}
\doublespacing

This deliverable exposes several mechanisms which will allow the connection and interaction between end-user's interfaces to third-party back-end services.

These back-end services cannot be directly used; hence they need to be encapsulated or wrapped into the so-called Resource Adapters within the FAST platform. The application of semantics to the back-end, through the corresponding resource adapters, and front-end building blocks ensures a powerful instrument in the task of building new gadgets, improving the search, and enhancing the connection among the different building blocks which compose a gadget.

Therefore, the focus of this deliverable is to define how these wrappers will be constructed to allow the FAST platform to exploit web services \cite{GustavoAlonso2003} such as RESTful web services, SOAP-based web services and semantic web services through WSMO, and define mechanisms to connect them within the gadgets.

\newpage

%%%%%%%%%%%%%%%%%%%%%
% Document Summary %
%%%%%%%%%%%%%%%%%%%%%

\clearpage

\section*{Document Summary}
% double spacing from here on:
\singlespacing
\begin{small}

\begin{tabular}
	%{| >{\columncolor{fast@lightgrey}}p{3.25cm}|p{6cm}|p{2cm}|p{2cm}|}
	{| >{\columncolor{fast@lightgrey}}p{3.25cm}|p{6cm}|p{2cm}|p{2cm}|}
	\hline
	\textcolor{white}{\textbf{Code}} & {FP7-ICT-2007-1-216048} & {\textbf{Acronym}} & {FAST}\\ \hline
	\textcolor{white}{\textbf{Full title}} & \multicolumn{3}{l|}{Fast and Advanced Storyboard Tools}\\ \hline
	\textcolor{white}{\textbf{URL}} & \multicolumn{3}{l|}{\url{http://fast.morfeo-project.eu}}\\ \hline
	\textcolor{white}{\textbf{Project officer}} & \multicolumn{3}{l|}{Annalisa Bogliolo}\\ \hline
\end{tabular}

\vspace{0.5cm}

\begin{tabular}
	{| >{\columncolor{fast@lightgrey}}p{3.25cm}|p{1.25cm}|p{1cm}|p{1cm}|p{6.32cm}|}
	\hline
	\textcolor{white}{\textbf{Deliverable}} & {\textbf{Number}} & {\deliverableNumber} & {\textbf{Name}} & {\deliverableTitle}\\ \hline
	\textcolor{white}{\textbf{Work package}} & {\textbf{Number}} & {\workpackageNumber} & {\textbf{Name}} & {\workpackageTitle}\\ \hline
\end{tabular}

\vspace{0.5cm}

\begin{tabular}
	{| >{\columncolor{fast@lightgrey}}p{3.25cm}|p{1.4cm}|p{3.28cm}|p{1.6cm}|p{3.29cm}|}
	\hline
	\textcolor{white}{\textbf{Delivery data}} & {\textbf{Due date}} & {27/02/2009} & {\textbf{Submitted}} & {26/02/2009}\\ \hline
	\textcolor{white}{\textbf{Status}} & \multicolumn{2}{l|}{} & \multicolumn{2}{l|}{final}\\ \hline
	\textcolor{white}{\textbf{Dissemination Level}} & \multicolumn{4}{l|}{Public $\boxtimes$ / Consortium $\square$}\\ \hline
	\textcolor{white}{\textbf{Short description of contents}} & \multicolumn{4}{p{10.85cm}|}{This deliverable presents techniques to exploit different kind of web services such as RESTful, SOAP-based and WSMO services. It exposes how these services are commonly defined, and what FAST need to allow these web services to be use within a gadget. In this deliverable is also presented a tool which apply some of these techniques allowing users to create the necessary wrappers for these services.}\\ \hline
	\textcolor{white}{\textbf{Authors}} & \multicolumn{4}{l|}{\authorOne}\\
	{} & \multicolumn{4}{l|}{\authorTwo}\\ 
%	{} & \multicolumn{4}{l|}{}\\ 
%	{} & \multicolumn{4}{l|}{}\\
	\hline
	\textcolor{white}{\textbf{Deliverable Owner}} & \multicolumn{2}{l|}{\authorOne} & \textbf{email} & {ismael.rivera@deri.org} \\ \cline{4-5}
	\textcolor{white}{\textbf{(Partner)}} & \multicolumn{2}{l|}{} & \textbf{phone} & {+353 91 495338} \\ \hline
	\textcolor{white}{\textbf{Keywords}} & \multicolumn{4}{p{10.85cm}|}{FAST, web service, WSDL, REST, SOAP, WSMO, Resource Adapter}\\ \hline
\end{tabular}
\end{small}
\newpage

%%%%%%%%%%%%%%%%%%%%%
% TABLE OF CONTENTS %
%%%%%%%%%%%%%%%%%%%%%
\doublespacing
\setcounter{tocdepth}{3}
\tableofcontents
\cleardoublepage
% \pagenumbering{arabic}

%\clearpage
%\listoftables

\clearpage
\listoffigures

%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGINNING OF SECTIONS %
%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
% \rofoot{\small{Page \thepage\ of \pageref{LastPage}}}

\section{Introduction} % (fold)
\label{sec:introduction}

\subsection{Goal and Scope} % (fold)
\label{sub:goal_and_scope}

The objective of this deliverable is the analysis and development of mechanisms to facilitate the connection between gadgets and underlying Web services, based on front-end user requirements and on the semantic descriptions of the service wrappers, and the development of these service wrappers from the Web services' APIs and formal descriptions.

% subsection goal_and_scope (end)

\subsection{Structure of the Document} % (fold)
\label{sub:structure_of_the_document}

This deliverable is structured as follows: Section~\ref{sec:introduction} states the goal, scope and structure of the document. Before going to the core of the document, a brief introduction to some related work is done in Section~\ref{sec:related_work}. Then, Section~\ref{sec:resource_adapters} describes what a resource adapter is, how the platform is able to interact with web services, how these wrappers or adapters are build and then discovered to be reused in any gadget. Finishing the deliverable, Section~\ref{sec:restful_web_services_wrapper_tool} defines the service wrapper tool built to facilitate FAST users to create resource adapters of RESTful web services.

% section introduction (end)


\clearpage
\section{Related Work} % (fold)
\label{sec:related_work}

This section focuses on different approaches dealing with web services integration and reutilisation. That is not a novel idea, since one of the basic pillars of web services is to allow any application to access and execute third-party web services over a network, and there are already loads of approaches about this issue. However, most of these approaches require a high-level technical profile to accomplish this integration in a programmatically manner. The ones studied in this deliverable are those which presents and allow reusing data sources and web services using a graphical interface or wizard.

\cite{urmetzer2010fast_state_of_the_art} presented several tools to create widgets, which allow the interaction with some kind of data sources and services. Yahoo! Pipes provides a set \emph{modules} to access different kind of data sources, such as RSS feeds, a given web page (HTML code), Flickr images, Google base or the Yahoo! search engine, among others. These modules are developed by the widget platform itself, they do not allow users to build their own modules, and it lacks of a way to interact with REST or SOAP web service. Another tool to reference is Apatar. Apatar is more enterprise-oriented, allowing the interaction with databases (MySQL, PostgreSql, Oracle), and powerful enterprise systems such as Salesforces.com or SugarCRM. It also provides access to data sources such as XML or text files. But again, there is no way to use web services. Finally, Presto is another solution enterprise-oriented. It allows the common data sources such as RSS and ATOM feeds or XML-based sources. However, Presto brings connectors to use services from HP SOA Systinet and any Oracle information technologies including Oracle 9i/10g/11g, Oracle Fusion SOAs, and Oracle Applications.

Summarising up, none of the solutions in the market really facilitate the users to build up their own widgets using any kind of web service in a graphical manner. Their approaches are either data-oriented (RSS feeds, databases, raw text), or including a small set of web services in the case of Presto. FAST will bring the possibility of integrate REST or SOAP-based web service inside a gadget (by creating service wrappers), and graphical tool will be provided to facilitate the process of building these service wrappers. In a similar way, and in the context of bioinformatics web services, \cite{gordon2008} explains how to publish web services to be reused in their tool as Moby (semantic) services. They have developed the Daggoo\footnote{http://www.daggoo.net/} prototype which will create these service wrappers to be used in Moby.

% section related_work (end)


\clearpage
\section{Resource Adapters} % (fold)
\label{sec:resource_adapters}

In the context of FAST philosophy, a service is a software element or system, often deployed within enterprise boundaries, designed to support interoperable Machine-to-Machine interaction over a network (e.g. Web Services, Databases, CORBA or RPC interfaces...). These services have to be used by the gadgets, but there are several complications to be resolved in order for the front-end (i.e. the gadget user interface and logic) to communicate with those services, such as the disparity of interfaces and invocation mechanisms. Another issue is the complexity for an end-user to interact with those services. Hence, this interaction will be shifted to a user-interaction paradigm through a user-friendly graphical interface (service front-end), allowing both humans and machines to interact with the services through a uniform fashion.

The following sections explain what a resource adapter is, how a user, in this case a resource developer, can build these resource adapters, and how another user, a screen developer for instance, is able to discover and connect them while creating a screen. Hence, these three phases are called: building, discovery and connection.

\subsection{Definition} % (fold)
\label{sub:definition}

A complex gadget in terms of FAST is aimed to provide a functional access from a graphical user interface to a set of services (SOAP or REST-based Web services) and data sources (Atom/RSS feeds). These services and data sources need to be modelled and encapsulated within the platform in order to allow being discovered and used by other components (i.e. forms and operators). These service wrappers are called Resource Adapters in the FAST platform. Figure~\ref{fig:complex_gadget_architecture} illustrates the role they play and which other building blocks they interact with within a gadget.

\begin{figure}[!htb]
  \begin{center}
    \includegraphics[width=\linewidth]{images/ComplexGadgetArchitecture.pdf}
    \caption{Complex Gadget Architecture}
    \label{fig:complex_gadget_architecture}
  \end{center}
\end{figure}

Basically, a resource adapter, from a design point of view, is composed of:

\begin{enumerate}
	\item \textbf{metadata} such as creator, label, description, version, and so on,
	\item a set of \textbf{actions} or operations, with their corresponding preconditions,
	\item and a set of \textbf{postconditions} or outputs of the resource.
\end{enumerate}

Figure~\ref{fig:resource_adapter_overview} shows the information above in a graphical manner. An action (represented by a white square) is the minimal unit of functionality a resource may have. Imagine a user clicking on a button to get a list of items for sale, or a checkout action performed in order to buy one of the items from the list. As an analogy, an action is what a operation is in a SOAP-based web service. Moreover, as these operations require some input, the actions may need a certain precondition (green circles) to be satisfied. And at last, the execution of these action may cause a postcondition (red circle) be satisfied, or following the same example, an output is returned as result of the execution of an operation.

\begin{figure}[!htb]
  \begin{center}
    \includegraphics[width=12cm]{images/resource_adapter.pdf}
    \caption{Resource Adapter Overview}
    \label{fig:resource_adapter_overview}
  \end{center}
\end{figure}

% subsection definition (end)

\subsection{Building} % (fold)
\label{sub:building}

This section describes different approaches for describing and implementing web services, and how a resource adapter could be generated for these services.

\subsubsection{REST-based Web Services} % (fold)
\label{ssub:rest_based_web_services}

REST \cite{Fielding2000} is a term used to describe an architecture style, not a standard, of networked systems. The acronym REST stands for Representational State Transfer. REST-based or RESTful web services are created identifying all the conceptual entities or resources which need to be exposed as services. Those entities or resources should be nouns, not verbs (orders, tickets, etc.). Then, the interaction with those resources is made by convention using HTTP verbs such as GET, POST, PUT or DELETE, in order to retrieve, create, modify or delete them.

RESTful web services are more light-weight than SOAP-based web services, avoiding the verbose XML-based messages, but unlike the former, which have a standard and commonly used vocabulary to describe the web service interface through WSDL, RESTful web services are currently not formally described most of the times. For a service consumer to understand the context and content of the data that must be sent to and received from the service, both the service consumer and service producer must have an out-of-band agreement. This takes the form of documentation, sample code, and an API that the service provider publishes for developers to use. For example, the most web-based services available from Google, Yahoo, Flickr, Amazon, and so on have accompanying artifacts describing how to consume the services. This style of documenting REST-based web services is fine for developers' use, but it averts tools from programmatically consuming such services and generating executable stubs for a given programming language, as a web service described using WSDL allows. Nevertheless, Web Application Description Language (WADL) attempts to resolve some of these issues by providing a means to describe services in terms of schemas, HTTP methods, and the request or response structures exchanged, but this language is not widely adopted yet by RESTful web service developers.

To permit a high number of REST-based web services to be integrated to the FAST platform, the approach taken is from a manual development perspective. There is no need of a formal document such as WADL defining the web service, for this reason, building service wrappers for these services involve the correct understanding of the service by a human being and a tool to facilitate this task. This tool is explained in detail in Section~\ref{sec:restful_web_services_wrapper_tool}.

% subsubsection rest_based_web_services (end)

\subsubsection{SOAP Web Services} % (fold)
\label{ssub:soap_web_services}

SOAP-based web Services or "Heavyweight Web Services" use Extensible Markup Language (XML) \cite{XML1.1} messages that follow the Simple Object Access Protocol (SOAP) standard \cite{SOAP1.2} and have been popular within traditional enterprise, usually relying on HTTP for message negotiation and transmission. In such services, there is often a machine-readable description of the operations offered by the service written in a Web Services Description Language (WSDL) document. The advantage of specifying the service using WSDL is that it can be programmatically processed. 

Shortly, a WSDL definition of a service, regarding the WSDL 2.0 specification \cite{WSDL2.0}, will contain the following information:
\begin{description}
	\item[Interfaces] A set of Interface components describing sequences of messages that a service sends and/or receives.
	\item[Bindings] A set of Binding components describing concrete message formats and transmission protocols which may be used to define the endpoints.
	\item[Services] A set of Service components describing a set of endpoints at which a particular deployed implementation of the service is provided.
	\item[Element declarations] A set of Element Declaration components defining the name and content model of the element information items such as that defined by an XML Schema global element declaration.
	\item[Type definitions] A set of Type Definition components defining the content model of the element information items such as that defined by an XML Schema global type definition.
\end{description}

From a specific WSDL definition, a set of methods or operations can be easily extracted which encloses a set of inputs and outputs. These operations would be transformed into \emph{actions}, and the inputs and outputs would be used to define resource adapter \emph{pre/postconditions}. But there is a critical problem following this approach. The definition of the inputs, outputs, operations and their types are done in a XML Schema document. An XML schema describes, in a syntactic manner, the structure of an XML document, but there is no straight-forward relation with the concepts used to describe pre and postconditions in the building blocks. In order to illustrate the concepts of WSDL, and the gap between them and semantically-defined building blocks, a shorten version of a real Amazon E-commerce web service will be presented. Concretely, the choosen web service performs an item search through the Amazon catalog. It expects as input an ItemSearch element, which may contain an actor, an artist or an author, and the item availability. The output of the service would be a set of items. The WSDL including for this service is given below.

\singlespacing
\begin{small}
\verbatiminput{examples/amazon.wsdl}
\end{small}
\doublespacing

As stated before, one of the advantages of describing web services in a formal document is that they can be programmatically consumed. In fact, there are many frameworks out there to facilitate such a task, parsing WSDL files, creating stubs to consume the web service and so on. However, in order to create a resource adapter from the WSDL defined above, the types defined in the XML Schema need to be translated into concepts from an ontology.

This problem could be addressed in two different ways. First one, as a manual process mapping these types and their attributes to concepts and properties, as it was proposed for RESTful services. Second approach is taking advantage of SAWSDL, which would help ensure a programatical (mapping) process.

SAWSDL \cite{sawsdl} stands for Semantic Annotations for WSDL and XML Schema, and it defines how to add semantic annotations to various parts of a WSDL document such as input and output message structures, interfaces and operations. These semantic annotations enable the possibility to develop resource adapters from WSDL documents. They reference a concept in an ontology or a mapping document, and are either independent of the ontology expression languages or mapping languages.

Basically, there are three main attributes used in SAWSDL: \emph{modelReference} to specify the association between a WSDL or XML Schema component and a concept from the ontology, and \emph{liftingSchemaMapping} and \emph{loweringSchemaMapping} to define the mapping mechanisms between semantic data and XML. These lowering and lifting schema mappings are not explained in this deliverable, however in Appendix A of the SAWSDL specification \cite{sawsdl} they are described in detail, and illustrated with examples.

To illustrate the usage of these attributes, the following code shows a fragment of the previous example using SAWSDL to semantically annotate the service with concepts from an imaginary ontology defining the Amazon E-commerce web service.

\singlespacing
\begin{small}
\verbatiminput{examples/amazon_sawsdl.wsdl}
\end{small}
\doublespacing

Hence, SAWSDL enriches the web services descriptions made in WSDL with references to concepts from a semantic model and enables the possibility to create resource adapters from these definitions without a strong user participation in the process. If the semantic metadata is missing, a manual annotation process could be considered, where the user would need to relate concepts from an ontology with the WSDL or XML Schema elements.

% subsubsection soap_web_services (end)

\subsubsection{WSMO Web Services} % (fold)
\label{ssub:wsmo_web_services}

Semantic web services bring a number of advantages in the creation of the resources adapters over classic web services. Formal and semantic descriptions of web services allow the creation of mechanisms to raise their exploitation in a more automatic way. In this section, some general notions of the Web Service Modelling Ontology (WSMO) will be explained and how FAST can make use of it.

In a few words, WSMO provides means to describe all relevant aspects of semantic web services in a unified manner. A web service description in WSMO consists of five sub-components: non-functional properties, imported ontologies, used mediators, a capability and interfaces. However, we will focus on the capabilities and the interfaces since they are components which will make possible the integration of these services in FAST.

Capabilities and interfaces are the two types of web service description in WSMO. The capabilities describe the different functions of the web service, while the interfaces specify:
\begin{enumerate}
	\item How to communicate with a web service in order to avail of its functionality. This is called Choreography.
	\item How the functionality of a web service is enabled by interacting with other web services. This is called Orchestration.
\end{enumerate}

A web service in WSMO defines one and only one capability. The capability of a web service defines its functionality in terms of pre/postconditions, assumptions and effects. Apart from that, a web service capability is defined by specifying the following elements: non-functional properties, imported ontologies, used mediators, and shared variables. The creation of the resource adapters for these web services will just take into consideration the set of pre/postconditions.

In the rest of the section, the Amazon E-commerce web service will be used to build a WSMO web service with the same functionality \cite{wsmo_amazon}. In fact, just the small subset of the service, used in previous sections, will be tranformed.

First of all, an ontology is needed describing the Amazon domain. For the sake of simplicity, it will be created doing a one-to-one mapping between the XML Schema types and the concepts, though a real sceneario may consider a different approach to optimise the modelling.

The concept describing an item search request for the Amazon web service is:

\singlespacing
\begin{small}
\begin{verbatim}
concept itemSearchRequest
    nonFunctionalProperties
      dc#description hasValue "A request to search for an item"
    endNonFunctionalProperties
    author ofType _string
    title ofType (1) _string
    rating ofType ratings#audienceRating
    minPrice ofType (1) _decimal
    maxPrice ofType (1) _decimal
\end{verbatim}
\end{small}
\doublespacing

The concept \emph{itemContainer} describes a list of items returned in the item search response, and its code is presented below:

\singlespacing
\begin{small}
\begin{verbatim}
concept itemContainer
    nonFunctionalProperties
      dc#description hasValue "Contains a list of items"
    endNonFunctionalProperties
    items ofType item
\end{verbatim}
\end{small}
\doublespacing

Next step would be to describe the namespace and non-functional properties declarations for the WSMO Amazon web service, but as it was said, this information is not relevant for the example. Hence, the simplified version of the Amazon web service preconditions would look like:

\singlespacing
\begin{small}
\begin{verbatim}
precondition
  nonFunctionalProperties
     dc#description hasValue "The Amazon service handles requests 
     for searching for items by keywords"
  endNonFunctionalProperties
  definedBy
    // A search by author, title, minPrice or maxPrice
    ?request memberOf am#itemSearchRequest
\end{verbatim}
\end{small}
\doublespacing

It is a fairly simple precondition, for which the only condition required is the existence of a \emph{itemSearchRequest} object.

However, postconditions are a bit more difficult to construct. They take the form of implication rules, so given a particular precondition, one particular postcondition will take effect. To follow the same example, these would be the postconditions for the Amazon search items functionality, including just the criterion author, title, minimum and maximum price as defined in the ontology.

\singlespacing
\begin{small}
\begin{verbatim}
 postcondition
  nonFunctionalProperties
    dc#description hasValue "The service returns a list of searched
      items"
  endNonFunctionalProperties
  // The result for a search request by author is a container of products
  // such that all items in the container have the requested author
  (?request[
      author hasValue ?author
    ] memberOf am#searchItems implies 
    exists ?container 
      (?container memberOf am#itemContainer and 
        forall ?item 
          (?container[
              items hasValue ?item
            ] implies 
            ?item[
              author hasValue ?author
            ]
          )
      )
  ) and
  
  // The result for a search request by title is a container of products
  // such that all items in the container have the requested title
  (?request[
      title hasValue ?title
    ] memberOf am#searchItems implies 
    exists ?container 
      (?container memberOf am#itemContainer and 
        forall ?item 
          (?container[
              items hasValue ?item
            ] implies 
            ?item[
              title hasValue ?title
            ]
          )
      )
  ) and 
  
  // The result for a search request by minPrice is a container of products
  // such that all items in the container have a price >= requested minPrice
  (?request[
      minPrice hasValue ?minPrice
    ] memberOf am#searchItems implies 
    exists ?container 
      (?container memberOf am#itemContainer and 
      forall{?item,?price} 
        (?container[
            items hasValue ?item
          ] and 
          ?item[
            price hasValue ?price
          ] implies 
          ?price >= ?minPrice
        )
      )
  ) and 
  
  // The result for a search request by maxPrice is a container of products
  // such that all items in the container have a price <= requested maxPrice
  (?request[
      maxPrice hasValue ?maxPrice
    ] memberOf am#searchItems implies 
    exists ?container 
      (?container memberOf am#itemContainer and 
      forall {?item,?price} 
        (?container[
            items hasValue ?item
          ] and 
          ?item[
            price hasValue ?price
          ] implies 
          ?price =< ?maxPrice
        )
      )
  ).
\end{verbatim}
\end{small}
\doublespacing

The manner pre/postconditions are defined in WSMO web services are similar to the way they are defined in the Resource Adapters. Section 4.4 in \cite{moller2010fast_ontology} gives a detailed explanation on this topic. Basically, using previous examples, the preconditions would be transformed as follows:

\begin{verbatim}
?request memberOf am#itemSearchRequest => ?request rdf:type am:itemSearchRequest
\end{verbatim}

And a simple postcondition would be transformed as follows:

\begin{verbatim}
exists ?container 
      (?container memberOf am#itemContainer) => ?container rdf:type am:itemContainer
\end{verbatim}

In the previous example, there is not a formal expression saying that \emph{?container} must exists, but it is assumed.

% subsection building (end)

\subsection{Discovery} % (fold)
\label{sub:discovery}

In the building phase, every resource adapter is created sharing a common structure for screen components, such as forms, operators and resources. Hence, it will have a set of actions which will contain a set of preconditions to be satisfied in order to be executed, and after its execution, it may produce any of the conditions of their postconditions.

For this reason, a screen developer during the development phase is able to reuse these screen components which are already stored in the catalogue, establishing which the screen's pre and postconditions are, and then the system will suggest several screen components which may satisfy these pre or postconditions. In a first step, the system will suggest screen components having any of the required preconditions, which can be connected to any of the screen preconditions (the connection will be represented by an internal pipe), and the same would happen for the postconditions. Once a screen component is inserted into the screen, the system will take its definition into consideration to recommend new screen components which can be connected to the ones the screen is composed of.

On these basis, the mechanism is relatively similar to the screen recommender, used to find the best screens to create a screen flow. Once more, it is based on the pre/postconditions of a set of building blocks.

% subsection discovery (end)

\subsection{Connection} % (fold)
\label{sub:connection}

The aim of a resource adapter is to perform some action on a web service. In order to perform a given action, a precondition may need to be fulfilled, and as a result of the execution a postcondition may be generated. These pre/postconditions are intended to be used by pre/postconditions of other building blocks within a gadget. This connection must be explicitly defined, because it will indicate the real data-flow between different building blocks. In FAST this is commonly called Piping, since a pipe in computer science is just that, a one-way communication channel for interprocess communication; therefore a pipe is a logical connection made between a precondition and a postcondition of different building blocks. Figure~\ref{fig:Piping} shows an example of a search form for the Amazon service. This is a screen, composed by a form and a resource adapter. The form allows the user to introduce a search term, producing a postcondition which will be redirected to a resource adapter precondition. The execution of the web service produces a list of results, which will be forwarded to the postcondition of the screen.

\begin{figure}[!htb]
  \begin{center}
    \includegraphics[width=12cm]{images/piping.pdf}
    \caption{Piping}
    \label{fig:Piping}
  \end{center}
\end{figure}

% subsection connection (end)

% section web_services_wrapping (end)

\clearpage
\section{RESTful Web Services Wrapper Tool} % (fold)
\label{sec:restful_web_services_wrapper_tool}

In FAST, the wrapper tool will be in charge of the resource adapters' building phase. At the moment, it just supports RESTful web services. The building phase for this type of web services wrapper is done in two steps: a first step will be in charge of the construction of a service request and a second step will analyse the response got from the execution of the service, allowing the extraction of facts contained in that response and mapping them to domain-specific concepts from the ontologies used within FAST by any building block.

\subsection{Constructing service requests} % (fold)
\label{sub:constructing_service_requests}

As a first approach, the interaction with these services will be limited to retrieve information to feed the gadgets using simply GET requests. A service request would be assembled using a certain URL and a set of parameters. As an example, Ebay Shopping web service will be studied. The following URL is invoked to retrieve a list of items corresponding to certain search keywords:

\url{http://open.api.sandbox.ebay.com/shopping?appid=KasselUn-efea-4b93-9505-5dc2ef1ceecd&version=517&callname=FindItems&ItemSort=EndTime&QueryKeywords=USB&responseencoding=XML}

As you may see, the URL invoked is http://open.api.sandbox.ebay.com/shopping and the parameters used in the example are:
\begin{description}
	\item[appid] this is the application ID obtained to use the API.
	\item[version] the API version.
	\item[callname] in this case FindItems to search through all items in Ebay.
	\item[itemsort] sorting method for the list of items.
	\item[querykeywords] list of keywords.
	\item[responseencoding] format of the response message obtained by the invocation of the request.
\end{description}

If needed, a detailed specification of the Ebay Shopping API can be found at \cite{eBayShoppingAPIs}.

The above URL for searching items in Ebay is followed by the query parameters, which take the form \textit{argument=value}, where the arguments and values are URL encoded, and are separated by an ampersand (\&). For instance, the only relevant parameter the user would need to specify is \emph{querykeywords}, thus somehow the service has to receive an input value for it, while the other parameters can be set to a default value. However, in order to develop a generic wrapper for the any service, all parameters might be set by the user.

To achieve this, service wrappers will be handled as any other building block with preconditions and postconditions (inputs and outputs). Therefore, these precondition ports might be used to determine values for parameters like query keywords, coming from a building block inside the screen in which the service is placed or even an external screen, as a screen precondition.

To define the preconditions and postconditions of a new service wrapper, the FAST service wrapper tool provides a form allowing the edition of these entries, cf. Figure~\ref{fig:construct_pre_post_conditions}\footnote{Note: These example values may be used to test the service wrapper, but they can be freely edited.} 

\begin{figure}[!htb]
  \begin{center}
    \includegraphics[width=\linewidth]{images/ServiceWrapperToolGVSWithPortDefinitions.jpg}
    \caption{Configuring pre/postconditions of a service wrapper}
    \label{fig:construct_pre_post_conditions}
  \end{center}
\end{figure}

The service wrapper tool composes the request using a template string which will contain placeholders for precondition values. An example of a template with one placeholder (<search\_query>), to perform a search on google could be like:

\begin{verbatim}
http://www.google.com/search?lang=es&q=<search_query>
\end{verbatim}

Before sending the request to the service, the placeholders are filled with their corresponding values and the resulting URL is then ready to be sent as the service request. Following the previous example, the placeholder \emph{search\_query} is filled with a specific search term:

\begin{verbatim}
http://www.google.com/search?lang=es&q=six+nations+2010
\end{verbatim}

Figure~\ref{fig:construct_service_request} shows the screen to construct the service requests. In the top input field of Figure~\ref{fig:construct_service_request}, the user may drop an example HTTP request taken e.g. form the service documentation (e.g. \cite{eBayShoppingAPIs} for this example). The tool analyses the example request and, in the middle of the screen, a form for editing the request parameters is provided. This example shows how a user has connected the \textit{QueryKeywords} parameter with the precondition \textit{search\_key} by adding a corresponding reference to the value field of that parameter. In addition, an access key has been retrieved and has been entered as value for the \textit{appid} parameter.

\begin{figure}[!htb]
  \begin{center}
    \includegraphics[width=\linewidth]{images/ServiceWrapperToolGVSWithRequestExample.jpg}
    \caption{Constructing the service request URL and its parameters}
    \label{fig:construct_service_request}
  \end{center}
\end{figure}

Below the request parameter editing form of Figure~\ref{fig:construct_service_request}, a \textit{Send Request} button allows to validate the constructed service by sending it to the specified service address (via a server relay). Then the placeholders for preconditions are replaced with example values and the resulting HTTP request is shown below the parameter form. In addition, the request is sent and the response is shown on the bottom of that page, which helps the users to figure out quickly whether the constructed request works as desired. 

% subsection constructing_service_requests (end)

\subsection{Interpreting service responses} % (fold)
\label{sub:interpreting_service_responses}

Once the service request is constructed and sent to the service provider, it will send back a response. This response message could be serialized in any format, though the most common formats used nowadays are XML or JSON among others. To continue the example that was started in the previous section, the response of the Ebay Shopping service will be in XML as specified in the request, which is the format supported by the wrapper tool.

Figure~\ref{fig:response_service_execution} shows the transformation data tab of the wrapper tool. 

\begin{figure}
  \begin{center}
    \includegraphics[angle=90,width=0.8\linewidth]{images/ServiceWrapperToolGVSWithTransformationRules.jpg}
    \caption{Interactive rule based transformation of an XML response to FAST facts}
    \label{fig:response_service_execution}
  \end{center}
\end{figure}

Once the service response, in XML format, has been retrieved, the transformation tab shows it as an interactive object tree on the left side of Figure~\ref{fig:response_service_execution}. To construct this interactive object, the XML document has been parsed into a DOM, and a simplified tree representation of that DOM is built up. This tree representation of the XML data is used as an input to construct transformation rules.

The rule based approach of the service wrapper tool has been inspired by triple graph grammars \cite{Schurr94,JSZ97c}. While general triple graph grammars allow to relate complex structures to each other, in the approach taken for FAST, the target of a rule is always a single object or attribute making the process as easy as possible for the user.

A transformation rule is used to analyse the XML data and to generate domain-specific facts from concepts from the ontologies used by the pre/postconditions of the different building blocks. A transformation rule is composed of three elements (see the middle part of Figure~\ref{fig:response_service_execution}). First, the \textit{from} field indicates the XML elements to be translated by rule. These XML elements are identified by the tagname of a DOM element from the XML document. Second, the type of the rule will be set, taking one of the following values: \emph{createObject}, \emph{fillAttributes} or \emph{dummy}. And third, the target of the rule specifies a certain concept or attribute, to be created or filled. A detailed explanation of the type of actions to be triggered from the transformation rules is:

\begin{description}
	\item[action \emph{createObject}] specifies the creation of a new fact object. The type of that new fact is provided in the third compartment. In the example being explained, the root rule searches for XML elements with tagname \emph{FindItemsResponse} and for each such element a \emph{List} fact is created. The resulting facts are shown in a facts tree in the right of Figure~\ref{fig:response_service_execution}.
	\item[action \emph{fillAttributes}] does not create a new fact but it fills the value of the attribute provided as third part of such rules. In our example, the third transformation rule searches for XML elements with tagname \emph{Title}. Note, the rule is a sub-rule of the second rule, which generates \emph{Product} facts. Thus, the sub-rule searches for \emph{Title} tags only in the subtree of the XML data that has been identified by an application of the parent rule before. For example, the \emph{Item} rule may just have been applied to the first \emph{Item} element of the XML data. Then, the \emph{Title} rule is applied only to the first \emph{Item} sub-tree of the XML data and thus it will find only one \emph{Title} element in that sub-tree (not visible in Figure ~\ref{fig:response_service_execution} ). The value of that \emph{Title} element is then transfered to the \emph{productName} attribute of the corresponding \emph{Product} fact. Actually, our \textit{from} fields allow also to refer to parts of an XML attribute e.g. to \textit{words} 1 through 3. It is also possible to combine constant text and elements of multiple XML tree elements. 
	\item[action \emph{dummy}] does not create or modify any facts but such rules are just used to narrow the search space for their sub-rules. For example, in the Amazon case, the XML data for an item contains sections for \emph{minimum price}, \emph{maximum price}, and \emph{average price}. Each such section contains the \emph{plain price} and the \emph{formatted price}. Thus, in the Amazon case, a rule that searches for \emph{formatted price} elements within an \emph{Item} element would retrieve three matches. Using a dummy rule, we may first search for \emph{minimum price} elements and then search for \emph{formatted price} elements within that sub-tree.
\end{description}

Since FAST is storyboard oriented, the service wrapper tool follows the storyboard idea as well. Any time, a change to a transformation rule is done, the transformation process is triggered and the resulted facts tree is directly shown. This process helps the user to deal with the slightly complex semantics of the transformation rules avoiding errors or mistakes. In addition, FAST is semantic-driven, therefore, the service wrapper designer shall retrieve the domain-specific types from a FAST ontology server together with the structure of each type, i.e. together with a description of the attributes of each fact. Thus, the transformation rule editor is able to provide selection boxes for the target element of the rules. For a \emph{createObject} rule, this selection box shows the fact types available for that domain. For the \emph{fillAttributes} rules, the selection box shows the attributes of the fact type chosen in the parent rule. In addition, we may provide some analysis tool, which will help to guarantee that the facts generated by the transformation rules conform to the fact types defined in the corresponding FAST ontology. This helps to ensure that the facts generated will be compatible for precondition ports of subsequent filter steps.

% subsubsection translation_xml_into_facts (end)

% subsection interpreting_service_responses (end)

\subsection{Generating a Resource Adapter} % (fold)
\label{sub:generating_a_resource_adapter}

Once the wrapping of a service has been defined and tested in the service wrapper tool, it shall generate an implementation of the desired Resource Adapter in JSON, HTML, and JavaScript, ready to be deployed and executed inside a screen. This service wrapper implementation is compliant with the formats required by the Gadget Visual Storyboard Tool (GVS) and it shall be stored inside the FAST catalogue, in order to be found and used by any user.

% subsection generating_a_resource_adapter (end)

\subsection{Limitations} % (fold)
\label{sub:limitations}

The rule driven approach presented above is somewhat limited. It is deliberately restricted to such a simple rule mechanism in order to keep things simple enough for end-users. Still, the selected approach suffices for most practical and real world cases. As a more complex example, the XML data for a person may provide two different tags for the first and the last name of a person. Contrarily, a person fact which conforms to a certain ontology for that domain may provide only one \emph{fullname} attribute that shall be filled by a concatenation of the first and the last name. To achieve this, the \textit{from} field of that tranforamtion rule might look like: \texttt{lastname"', "`firstname}. We are also able to do some navigation in the XML tree to follow XRef elements. For example the attribute \texttt{grandmother} could be filled using \texttt{mother.mother} in the \textit{from} field. 

However, there are some transformations that these rules cannot perform. For example, we do not support any mathematical operations. Thus, transforming e.g. Fahrenheit into Celsius temperatures is not supported. To cover such  cases, intermediate fact formats can be used which would allow generating facts to be further processed by additional filters. Such additional filters may be realized using (hand coded) operators, since some generic operators can act as filters for aggregation and conversions of facts from multiple sources. Then, service wrappers in combination with these filter operators will allow covering some of these complex cases.

% subsection limitations (end)

% section restful_web_services_wrapper_tool (end)

\clearpage
\bibliographystyle{apalike}
\addcontentsline{toc}{section}{References}
\bibliography{fast_d4_3_1}

\end{document}
