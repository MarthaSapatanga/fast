\documentclass{fast_latex}

% yay! We can use any kind of funky diacritic:
\usepackage[utf8]{inputenc}

\usepackage{lastpage}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage[pdfborder={0 0 0}]{hyperref}		% turn on when latex is used (not miktec)
\usepackage{url} % LEO: urls \url{}
\usepackage{verbatim} % code and comment
\usepackage{longtable}
\usepackage{xspace}   % whitespace after a macro if no punctuation after the macro
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{longtable}
\usepackage{array}
\usepackage{amssymb} 
\parindent0pt

\newcommand\deliverableNumber{D4.3.2}
\newcommand\deliverableTitle{Mechanisms for Gadget-Service Connections and Gadget Functionality}
\newcommand\deliverableTitleShort{Mechanisms for Gadget-Service Connections}
\newcommand\workpackageNumber{4}
\newcommand\workpackageTitle{Visual composition of screen-flow resources and interoperability with back-end Web Services}
\newcommand\authorOne{Ismael Rivera (NUIG)}
\newcommand\authorTwo{Albert Zündorf (UniKas)}
\newcommand\authorThree{Author 3}
\newcommand\authorFour{Author 4}
\newtheorem{example}{\emph{Example}}

\begin{document}
% explicit hyphenations
%\hyphenation{RDF-Re-po-si-to-ry}
%\hyphenation{name-space}

%\fontfamily{tahoma}\selectfont
\def\note#1{\marginpar{\footnotesize#1}} % use this to show the notes in the document
%\def\note#1{} % use this to hide the notes



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TITLE PAGES 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{empty}

\pagenumbering{roman}

\begin{flushright}
	\includegraphics[width=3cm]{images/FP7_logo}
\end{flushright}

\vspace{1cm}

%\begin{minipage}[p]{15cm}
	\begin{center}
		\includegraphics{images/FAST_logo}\\
		\vspace{1cm}
		{\LARGE{\sffamily \emph{FAST AND ADVANCED STORYBOARD TOOLS}}}\\
		\vspace{0.5cm}
		{\LARGE \sffamily \emph{FP7-ICT-2007-1-216048}}\\
		\vspace{0.5cm}
		{\LARGE \sffamily \emph{http://fast.morfeo-project.eu}}\\
		\vspace{4cm}
		{\LARGE \sffamily \textbf{Deliverable \deliverableNumber}}\\
		\vspace{0.5cm}
		{\LARGE \sffamily \textbf{\deliverableTitle}}\\
		\vspace{2cm}
		{\large \sffamily \authorOne}\\
		{\large \sffamily \authorTwo}\\
		\vspace{0.5cm}
		\vfill
		{\large \sffamily Date: 25/02/2010}\\
		\vspace{1cm}
		{\sffamily FAST is partially funded by the E.C. (grant code: FP7-ICT-2007-1-216048).}
		
	\end{center}
%\end{minipage}


\clearpage
%%%%%%%%%%%%%%
% NEXT PAGES %
%%%%%%%%%%%%%%
\pagestyle{scrheadings}

\lohead{\includegraphics[width=4cm]{images/FAST_logo_transparent}}
%\cohead{\small\textcolor{fast@lightgrey}{\deliverableTitle}}
%\rohead{\small{\today}}
%\lofoot{\small\textcolor{fast@lightgrey}{Task Force Ontologies}}
\cofoot{\small{FAST 216048 --- \deliverableTitleShort}}
\rofoot{\small{\thepage}}

\newpage
%
%\section*{Authors}
%\authorOne \\
%%\authorTwo \\
%%\authorThree\\
%%\authorFour\\
%
%
%\vfill
%%\section*{Project Co-ordinator}
%%\hspace*{-2,5cm}\begin{minipage}[p]{14cm}
%%Dr. Ansgar Bernardi \\
%%German Research Center for Artificial Intelligence (DFKI) GmbH \\
%%Trippstadter Strasse 122 \\
%%D 67663 Kaiserslautern \\
%%Germany \\
%%Email: bernardi@dfki.uni-kl.de, phone: +49 631 205 3582, fax: +49 631 205 4910 \\
%%\end{minipage}
%
%
%\section*{Partners}
%Telef\'onica Investigaci\'on y Desarrollo (Telef\'onica I+D), Spain \\
%National University of Ireland, Galway (NUIG), Republic of Ireland \\
%Kassel University, Germany \\
%Cyntelix Corporation, Republic of Ireland \\
%SAP AG, Germany \\
%Universidad Polit\'ecnica de Madrid (UPM), Spain
%
%
%\vspace{0.3cm}
%\begin{footnotesize}
%Copyright: FAST Consortium 2009\\
%\end{footnotesize}

%\clearpage


\section*{Version History}

\begin{small}
\begin{tabular}{|l|l|l|p{7.5cm}|}
\hline
\rowcolor{fast@lightgrey}\textcolor{white}{\textbf{Rev. No.}} &
                            \textcolor{white}{\textbf{Date}} &
                            \textcolor{white}{\textbf{Author (Partner)}} &
							\textcolor{white}{\textbf{Change description}}\\ \hline
1.0 & 26.02.2010 & Ismael Rivera (NUIG), & Final version ready for external review \\ 
 & & Albert Zündorf (UniKas) & \\ \hline
2.0 & 27.02.2011 & Ismael Rivera (NUIG), & Final version ready for external review \\ 
 & & Albert Zündorf (UniKas) & \\ \hline
\end{tabular}
\end{small}

\color{black}

\vfill
%{\bf Explanations of abbreviations on front page}\\
%\\
%%Nature \\
%R: Report \\
%P: Prototype \\
%R/P: Report and Prototype \\
%O: Other \\
% \\
%Dissemination level \\
%PU: Public \\
%PP: Restricted to other FP6 participants \\
%RE: Restricted to specified group \\
%CO: Confidential, only for NEPOMUK partners \\

\newpage

%%%%%%%%%%%%%%%%%%%%%
% Executive Summary %
%%%%%%%%%%%%%%%%%%%%%

\clearpage

\section*{Executive Summary}
\doublespacing

This deliverable exposes several mechanisms which will allow the connection and interaction between end-user's interfaces to third-party back-end services.

These back-end services cannot be directly used; hence they need to be encapsulated in what in the FAST platform is called Resource Adapters. The application of semantics to the back-end, through the corresponding Resource Adapters, and front-end building blocks assures a powerful instrument in the task of building new gadgets, improving the search, and enhancing the connection among the different building blocks which compose a gadget.

Therefore, the focus of this deliverable is to define how these wrappers will be constructed to allow the FAST platform exploiting web services \cite{GustavoAlonso2003} such as RESTful web services, SOAP-based web services and semantic web services through WSMO, and define mechanisms to connect them within the gadgets.

\newpage

%%%%%%%%%%%%%%%%%%%%%
% Document Summary %
%%%%%%%%%%%%%%%%%%%%%

\clearpage

\section*{Document Summary}
% double spacing from here on:
\singlespacing
\begin{small}

\begin{tabular}
	%{| >{\columncolor{fast@lightgrey}}p{3.25cm}|p{6cm}|p{2cm}|p{2cm}|}
	{| >{\columncolor{fast@lightgrey}}p{3.25cm}|p{6cm}|p{2cm}|p{2cm}|}
	\hline
	\textcolor{white}{\textbf{Code}} & {FP7-ICT-2007-1-216048} & {\textbf{Acronym}} & {FAST}\\ \hline
	\textcolor{white}{\textbf{Full title}} & \multicolumn{3}{l|}{Fast and Advanced Storyboard Tools}\\ \hline
	\textcolor{white}{\textbf{URL}} & \multicolumn{3}{l|}{\url{http://fast.morfeo-project.eu}}\\ \hline
	\textcolor{white}{\textbf{Project officer}} & \multicolumn{3}{l|}{Annalisa Bogliolo}\\ \hline
\end{tabular}

\vspace{0.5cm}

\begin{tabular}
	{| >{\columncolor{fast@lightgrey}}p{3.25cm}|p{1.25cm}|p{1cm}|p{1cm}|p{6.32cm}|}
	\hline
	\textcolor{white}{\textbf{Deliverable}} & {\textbf{Number}} & {\deliverableNumber} & {\textbf{Name}} & {\deliverableTitle}\\ \hline
	\textcolor{white}{\textbf{Work package}} & {\textbf{Number}} & {\workpackageNumber} & {\textbf{Name}} & {\workpackageTitle}\\ \hline
\end{tabular}

\vspace{0.5cm}

\begin{tabular}
	{| >{\columncolor{fast@lightgrey}}p{3.25cm}|p{1.4cm}|p{3.28cm}|p{1.6cm}|p{3.29cm}|}
	\hline
	\textcolor{white}{\textbf{Delivery data}} & {\textbf{Due date}} & {28/02/2011} & {\textbf{Submitted}} & {25/02/2011}\\ \hline
	\textcolor{white}{\textbf{Status}} & \multicolumn{2}{l|}{} & \multicolumn{2}{l|}{final}\\ \hline
	\textcolor{white}{\textbf{Dissemination Level}} & \multicolumn{4}{l|}{Public $\boxtimes$ / Consortium $\square$}\\ \hline
	\textcolor{white}{\textbf{Short description of contents}} & \multicolumn{4}{p{10.85cm}|}{This deliverable presents techniques to exploit different kind of web services such as RESTful, SOAP-based and WSMO services. It gives an overview of the characteristics of each type, and how they match into the FAST philosophy, where the Resource Adapter encapsulates they functionality and make possible their execution. Then, the Service Wrapper Tool, which creates the resource adapters, is described, and how it addresses the different kind of supported web services.}\\ \hline
	\textcolor{white}{\textbf{Authors}} & \multicolumn{4}{l|}{\authorOne, \authorTwo}\\
%	{} & \multicolumn{4}{l|}{}\\ 
%	{} & \multicolumn{4}{l|}{}\\ 
%	{} & \multicolumn{4}{l|}{}\\
	\hline
	\textcolor{white}{\textbf{Deliverable Owner}} & \multicolumn{2}{l|}{\authorOne} & \textbf{email} & {ismael.rivera@deri.org} \\ \cline{4-5}
	\textcolor{white}{\textbf{(Partner)}} & \multicolumn{2}{l|}{} & \textbf{phone} & {+353 91 495338} \\ \hline
	\textcolor{white}{\textbf{Keywords}} & \multicolumn{4}{p{10.85cm}|}{FAST, web service, WSDL, REST, SOAP, WSMO, Resource Adapter}\\ \hline
\end{tabular}
\end{small}
\newpage

%%%%%%%%%%%%%%%%%%%%%
% TABLE OF CONTENTS %
%%%%%%%%%%%%%%%%%%%%%
\doublespacing
\setcounter{tocdepth}{3}
\tableofcontents
\cleardoublepage
\pagenumbering{arabic}

%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGINNING OF SECTIONS %
%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\rofoot{\small{Page \thepage\ of \pageref{LastPage}}}

\section{Introduction} % (fold)
\label{sec:introduction}

\subsection{Goal and Scope} % (fold)
\label{sub:goal_and_scope}

The objective of this deliverable is the analysis and development of mechanisms to facilitate the connection between screen-flow gadgets and underlying Web services, based on front-end user requirements and on the semantic descriptions of the service wrappers, and to develop these service wrappers from of the Web services' APIs and formal descriptions.

% subsection goal_and_scope (end)

\subsection{Structure of the Document} % (fold)
\label{sub:structure_of_the_document}

This deliverable is structured as follows. Section~\ref{sec:introduction} states the goal, scope and structure of the document. Section~\ref{sec:web_services_wrapping} describes what a service wrapper is, how the platform is able to interact with web services, and how these wrappers are built and discovered to be reused in the gadgets. Then, Section~\ref{sec:restful_web_services_wrapper_tool} defines the Service Wrapper Tool, built to facilitate FAST users to create Resource Adapters of different kind of web services. Finally, Section~\ref{sec:related_work} presents similar approaches and related work that have been investigated and re-used in a certain level.


% subsection structure_of_the_document (end)

\subsection{Changes from Previous Version} % (fold)
\label{sub:changes_from_previous_version}

This section enumerates and gives a brief overview of the changes made in the deliverable with regards to the version 1.0 released for the milestone M24.

\begin{itemize}
 \item The related work section has been renamed to ``Similar Approaches and Related Work'', and includes new approaches dealing with the topics covered by the Service Wrapper Tool, and how it re-uses concepts and techniques of some of them.
 \item ``Resources Adapters'' sections has been renamed to ``Wrapping Services'', and small changes have been made to this section.
 \item ``RESTful Web Service Wrapper Tool'' has been renamed to ``Service Wrapper Tool'' as the tool has evolved and now it supports the wrapping of WSDL and WSMO services, as well as RESTful services. Hence, this section describes how these web services are supported and how to construct them.
\end{itemize}

% subsection changes_from_previous_version (end)

% section introduction (end)

\clearpage
\section{Web Services Wrapping} % (fold)
\label{sec:web_services_wrapping}

In the context of FAST philosophy, a service is a software element or system, often deployed within enterprise boundaries, designed to support interoperable Machine-to-Machine interaction over a network (e.g. Web Services, Databases, CORBA or RPC interfaces...). These services have to be used by the gadgets, but there are several complications to be resolved in order to communicate the front-end (i.e. the gadget user interface and logic) with those services, such as the disparity of interfaces and invocation mechanisms. Another issue is the complexity for an end-user to interact with those services. Hence, this interaction will be shift to a user-interaction paradigm through a user-friendly graphical interface (service front-end), allowing both humans and machines to interact with the services through a uniform fashion.

Therefore, a complex gadget in terms of FAST is aimed to provide a functional access from a graphical user interface to a set of services (SOAP or REST-based Web services) and data sources (Atom/RSS feeds). These services and data sources need to be modelled and encapsulated within the platform in order to allow the discovery and use of them by other components (i.e. forms and operators). This is called Resource Adapter in the FAST platform. Figure~\ref{fig:complex_gadget_architecture} illustrates their position and interaction with the rest of the building blocks within a gadget.

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{images/ComplexGadgetArchitecture.pdf}
    \caption{Complex Gadget Architecture}
    \label{fig:complex_gadget_architecture}
  \end{center}
\end{figure}

Once a brief background has been shown, the following sections explain how a user, in this case a resource developer, can build Resource Adapters, and how another user, a screen developer for instance, will discover and connect them while creating a screen. Hence, these three phases are called: building, discovery and connection.

\subsection{Building} % (fold)
\label{sub:building}

\subsubsection{REST-based Web Services} % (fold)
\label{ssub:rest_based_web_services}

REST is a term to describe an architecture style, not a standard, of networked systems. The acronym REST stands for Representational State Transfer. REST-based or RESTful web services \cite{Fielding2000} are created identifying all of the conceptual entities or resources which want to be exposed as services. Those entities or resources should be nouns, not verbs (orders, tickets, etc.). Then, the interaction with those resources is made by convention using HTTP verbs such as GET, POST, PUT or DELETE, in order to retrieve, create, modify or delete them.

REST is lightweight (not a lot of extra xml markup, human readable results), but unlike SOAP-based web services, which have a standard vocabulary, and commonly used, to describe the web service interface through WSDL, RESTful web services are currently not formally described most of the times. For a service consumer to understand the context and content of the data that must be sent to and received from the service, both the service consumer and service producer must have an out-of-band agreement. This takes the form of documentation, sample code, and an API that the service provider publishes for developers to use. For example, the many web-based services available from Google, Yahoo, Flickr, Amazon, and so on have accompanying artefacts describing how to consume the services. This style of documenting REST-based web services is fine for use by developers, but it averts tools from programmatically consuming such services and generating artefacts specific to programming languages, as a web service described using WSDL allows. Nevertheless, Web Application Description Language (WADL) attempts to resolve some of these issues by providing a means to describe services in terms of schemas, HTTP methods, and the request or response structures exchanged, but this language is not widely adopted yet by RESTful web service developers.

To permit a high number of REST-based web services to be integrated to the FAST platform, the approach taken is from a manual development perspective. There is no need of a formal document such as WADL defining the web service, for this reason, building service wrappers for these services involve the correct understanding of the service by a human being and a tool to facilitate this task. This tool is explained in detail in Section~\ref{sec:restful_web_services_wrapper_tool}.

% subsubsection rest_based_web_services (end)

\subsubsection{SOAP Web Services} % (fold)
\label{ssub:soap_web_services}

SOAP-based web Services or "Heavyweight Web Services" use Extensible Markup Language (XML) \cite{XML1.1} messages that follow the Simple Object Access Protocol (SOAP) standard \cite{SOAP1.2} and have been popular with traditional enterprise, usually relying on HTTP for message negotiation and transmission. In such services, there is often a machine-readable description of the operations offered by the service written in a Web Services Description Language (WSDL) document. Hence, the advantage of using WSDL is that it can be programmatically processed. 

Shortly, a WSDL definition of a service, regarding the WSDL 2.0 specification \cite{WSDL2.0}, will contain the following information:
\begin{description}
	\item[Interfaces] A set of Interface components describing sequences of messages that a service sends and/or receives.
	\item[Bindings] A set of Binding components describing concrete message formats and transmission protocols which may be used to define the endpoints.
	\item[Services] A set of Service components describing a set of endpoints at which a particular deployed implementation of the service is provided.
	\item[Element declarations] A set of Element Declaration components defining the name and content model of the element information items such as that defined by an XML Schema global element declaration.
	\item[Type definitions] A set of Type Definition components defining the content model of the element information items such as that defined by an XML Schema global type definition.
\end{description}

From a specific WSDL definition, a set of methods or operations can be easily extracted which encloses a set of inputs and outputs. These operations would be transformed into actions, and the inputs and outputs would be used to define Resource Adapter pre-/post-conditions. With the use of this information along with the XML Schema defining the types, a Resource Adapter can be semantically defined.

To integrate WSDL defined services into the FAST platform, we again propose an interactivce approach: We extend the tool for REST service wrapping with the ability of loading WSDL definitions of a service and this WSDL definition is then exploited for guidance of the user through the Resource Adapter construction, cf. Section~\ref{sec:restful_web_services_wrapper_tool}.

% subsubsection soap_web_services (end)

\subsubsection{WSMO Web Services} % (fold)
\label{ssub:wsmo_web_services}

Semantic web services bring a number of advantages in the creation of the resources adapters over classic web services. Formal and semantic descriptions of web services allow mechanisms to raise its exploitation in a more automatic way. In this section, some general notions of the Web Service Modelling Ontology (WSMO) will be explained and how FAST can make use of it.

In a few words, WSMO provides means to describe all relevant aspects of semantic web services in a unified manner. A web service description in WSMO consists of five sub-components: non-functional properties, imported ontologies, used mediators, a capability and interfaces. However, we will focus on the capabilities and the interfaces since they are components which will make possible the integration of these services in FAST.

Capabilities and interfaces are the two types of Web Service description in WSMO. The capabilities describe the different functions of WSMO, while the interfaces specify:
\begin{enumerate}
	\item How to communicate with a web service in order to avail of its functionality. This is called Choreography.
	\item How the functionality of a web service is enabled by interacting with other Web Services. This is called Orchestration.
\end{enumerate}

A web service in WSMO defines one and only one capability. The capability of a web service defines its functionality in terms of pre-/post-conditions, assumptions and effects. A web service capability is defined by specifying the following elements: non-functional properties, imported ontologies, used mediators, shared variables, pre-condition, post-condition, assumption, and effect.

Basically, the web service will offers to a client a post-condition when some conditions are met in the information space (pre-condition). Effects and assumptions can stay out of this study, since they will not be taken into account by any of the building blocks of a gadget.

Like WSDL defined services, we incorporate WSMO services into the FAST platform in an interactive storyboard driven approach. The FAST tool described in Section~\ref{sec:restful_web_services_wrapper_tool} reads the WSMO specification of a service and exploits this information again for guidance for the construction of a Resource Adapter. 

% subsection building (end)

\subsection{Discovery} % (fold)
\label{sub:discovery}

In the building phase, every Resource Adapter is created sharing a common structure for screen components, such as forms, operators and resources. Hence, it will have a set of actions which will contain a set of pre-conditions to satisfy in order to be executed, and after its execution, it may produce any of the conditions of their post-conditions.

For this reason, a screen developer during the screen development phase is able to reuse these screen components which are already stored in the Catalogue, establishing which the screen's pre-/post-conditions are. These pre-/post-conditions and building blocks are then used to find other relevant screen components which may satisfy these pre-/post-conditions, or be a good fit for the current problem. A more detailed explanation on this topic can be found in~\cite{rivera2011catalogue_user_manual}.

% subsection discovery (end)

\subsection{Connection} % (fold)
\label{sub:connection}

The aim of a resource adapter is to perform some action on a web service. In order to perform a given action, a precondition may need to be fulfilled, and as a result of the execution a postcondition may be generated. These pre/postconditions are intended to be used by pre/postconditions of other building blocks within a gadget. This connection must be explicitly defined, because it will indicate the real data-flow between different building blocks. In FAST this is commonly called Piping, since a pipe in computer science is just that, a one-way communication channel for interprocess communication; therefore a pipe is a logical connection made between a precondition and a postcondition of different building blocks. Figure~\ref{fig:Piping} shows an example of a search form for the Amazon service. This is a screen, composed by a form and a resource adapter. The form allows the user to introduce a search term, producing a postcondition which will be redirected to a resource adapter precondition. The execution of the web service produces a list of results, which will be forwarded to the postcondition of the screen.

\begin{figure}[!htb]
  \begin{center}
    \includegraphics[width=12cm]{images/piping.pdf}
    \caption{Piping}
    \label{fig:Piping}
  \end{center}
\end{figure}

% subsection connection (end)

% section web_services_wrapping (end)


\clearpage
\section{Service Wrapper Tool} % (fold)
\label{sec:restful_web_services_wrapper_tool}

In FAST, the Service Wrapper Tool deals with the Resource Adapters' building phase. The building of resource adapters is done in three steps: in a first step, the pre- and post-conditions used to pass parameters between FAST building blocks and the resource adapter are defined. The second step constructs and parses the request to the Web service, and the third step analyses the response obtained from the execution of the service, allowing the extraction of facts contained in that response and mapping them to domain-specific classes or concepts from the ontologies used by the building blocks' conditions.

This deliverable takes as an example a \emph{Formula1} RESTful Web service in order to explain in an easy manner certain aspects of the Service Wrapper Tool.

\subsection{Defining pre- and post-conditions} % (fold)
\label{sub:resource_adapter_parameters}

In the first tab of the Service Wrapper Tool, the user defines the name and the pre- and post-conditions of the desired Resource Adapter, as illustrated in Figure~\ref{fig:construct_pre_post_conditions}. For the pre-condition, a name, a type, and an example value are provided. The type of a pre- or post-condition is chosen from a drop-down list of available concepts. The list of available concepts, together with its properties and some example data (instances) is retrieved from the Catalogue. The type of the properties or attributes of the concepts may be basic types, such as string, integer, date, etc., or other concepts, providing a good flexibility and support for a any kind of input/output for the Web services.

\begin{figure}
  \begin{center} \includegraphics[width=\linewidth]{images/ServiceWrapperToolGVSWithPrePostConds.png}
    \caption{Configuring pre- and post-conditions of a Resource Adapter}
    \label{fig:construct_pre_post_conditions}
  \end{center}
\end{figure}

These example values (instances) are used for testing requests during subsequent construction steps, and to assist the user with previous values for pre-/post-conditions which have already being used in another resource adapters.


\subsection{Constructing service requests} % (fold)
\label{sub:constructing_service_requests}

Following with the proposed example, the service request consists of a URL template that is easily retrieved from Formula1 API documentation. This URL template consists of the service URL or address \url{http://ergast.com/api} followed by the year to query for, and by the category \verb|drivers| we are interested in. The user may grab such an URL from the API documentation page of the targeted web service and drop it into the Request tab of the Service Wrapper Tool, cf. Figure~\ref{fig:construct_service_request}. The Service Wrapper Tool will then analyse the dropped URL and split it into its parts and provide a convenient form allowing to edit e.g. all the parameters of the URL. In our example the URL has no parameters so the parameter form shows only the base URL. 

For WSDL or WSMO services, the Service Wrapper Tool provides additional support for the construction of the request. The user may point to the WSDL or WSMO definition of the targeted service. The Service Wrapper Tool then reads this definition and analyses it. With the help of this information, the Service Wrapper Tool provides interactive guidance for selecting the desired operation from a service and then it retrieves the operation descriptions and fills the request parameter form adequately.

Now we have to connect the request parameters to the parameter values passed via the pre-conditions to the Resource Adapter. In our case, we replace the year part of the URL with a placeholder for the pre-condition season \verb|<season>|, see Request URL input field at the top of Figure~\ref{fig:construct_service_request}, which shows the screen to construct the service requests.

In this example, an HTTP GET request has to be constructed. The Service Wrapper Tool supports HTTP POST requests, and its design makes possible the addition of other HTTP verbs as HEAD, PUT or DELETE, among others. While in GET request the parameters are set in the URL itself, POST requests may include a body of data sent after the header lines. For unstructured POST bodies, a text area is provided allowing the user to fill in placeholders for references to pre-condition values. However, in structured POST bodies as in the case of WSDL and WSMO services, the POST body uses a structured text format. In Figure~\ref{fig:construct_service_request_wsdl} the user has loaded a WSDL definition of a \emph{geoip} web service into the tool. Then, a modal window shows a drop-down list with the different operations offered by the service. After the user selects an operation, in this example the GetGeoIP operation, the service wrapper tool retrieves the list of parameters for the GetGEoIP operation and construct the template of the POST body which is inserted in its specific textarea. The GetGeoIP operations accepts one parameter: IPAddress. Then the user is allow to connect parameters to preconditions using \verb|<IPAddress>| as the value for the parameter. 

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{images/ServiceWrapperToolGVSRequestTemplate.png}
    \caption{Constructing the service request and its parameters}
    \label{fig:construct_service_request}
  \end{center}
\end{figure}

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{images/ServiceWrapperToolGVSRequestTemplateWSDL.png}
    \caption{Importing WSDL service descriptions}
    \label{fig:construct_service_request_wsdl}
  \end{center}
\end{figure}

Below the request parameter editing form of Figure~\ref{fig:construct_service_request}, a \emph{Send Request} button allows to validate the constructed request by sending it to the specified service address. Then the placeholders for pre-conditions are replaced with example values and the resulting request is shown below the parameter form. In addition, the request is sent and the response is shown at the bottom of interface. This gives the user a fast feedback whether the constructed request works as desired. 

% subsection constructing_service_requests (end)

\subsection{Interpreting service responses} % (fold)
\label{sub:interpreting_service_responses}

Once the service request is constructed and sent to the service provider, it will send back a response. This response message could be serialize in any format, though the most common formats used nowadays are XML or JSON. To continue the example started in the previous section, the response of the Formula1 service will is formatted in XML, although the Service Wrapper Tool supports both JSON and XML.

\subsubsection{Translation XML/JSON into Facts} % (fold)
\label{ssub:translation_xml_into_facts}

Once the service response has been retrieved, it is shown in the transformation tab as an interactive object tree, as it can be seeing on the left side of Figure~\ref{fig:response_service_execution}. To construct this interactive object tree, the XML or JSON document is parsed into a DOM, and a simplified tree representation of the given DOM is built up. This tree representation of the XML/JSON data is used as an input to construct the transformation rules.

\begin{figure}
  \begin{center}
      \includegraphics[angle=90,width=0.8\linewidth]{images/ServiceWrapperToolGVSWithTransformationRulesF1.png}
    \caption{Interactive, rule based transformation of a XML response into FAST facts}
    \label{fig:response_service_execution}
  \end{center}
\end{figure}

A transformation rule approach is used to analyse the XML/JSON data and to generate domain-specific facts from concepts of the ontologies used by the pre-/post-conditions of the different building blocks. A transformation rule is composed of three elements, as the middle part of Figure~\ref{fig:response_service_execution} shows. First, the \textit{from} field indicates the XML elements to be translated by rule. These XML elements are identified by the tagname of a DOM element from the XML document. Second, the type of the rule, taking one of the following values: \emph{createObject}, \emph{fillAttributes} or \emph{dummy}. And third, the target of the rule specifies a certain concept or attribute, to be created or filled. A detailed explanation of the type of actions to be triggered from the transformation rules is:
\begin{description}
	\item[action \emph{createObject}] specifies the creation of a new fact object. The type of that new fact is provided in the third input box. In the example being explained, the root rule searches for XML elements with tagname \emph{DriverTable} and for each such element a \emph{List} fact is created. The resulting facts are shown in a facts tree in the right of Figure~\ref{fig:response_service_execution}.
	\item[action \emph{fillAttributes}] does not create a new fact but it fills the value of the attribute provided as third part of such rules. In our example, the third transformation rule searches for XML elements with tagname \emph{FamilyName}. Note, the rule is a sub-rule of the second rule, which generates \emph{Person} facts. Thus, the sub-rule searches for \emph{FamilyName} tags only in the subtree of the XML data that has been identified by an application of the parent rule before. For example, the \emph{Driver} rule may just have been applied to the first \emph{Driver} element of the XML data. Then, the \emph{FamilyName} rule is applied only to the first \emph{Driver} sub-tree of the XML data and thus it will find only one \emph{FamilyName} element in that sub-tree. The value of that \emph{FamilyName} element is then transfered to the \emph{name} attribute of the corresponding \emph{Person} fact. Actually, our \textit{from} fields allows also to refer to parts of an XML attribute e.g. to \textit{words} 1 through 3. It is also possible to combine constant text and elements of multiple XML tree elements. A \textit{from} field may also refer to multiple tags of the source tree, e.g. to combine a full name from a first name and a family name field.  
	\item[action \emph{dummy}] does not create or modify any facts but such rules are just used to narrow the search space for their sub-rules. For example, in the Amazon case, the XML data for an item contains sections for \emph{minimum price}, \emph{maximum price}, and \emph{average price}. Each such section contains the \emph{plain price} and the \emph{formatted price}. Thus, in the Amazon case, a rule that searches for \emph{formatted price} elements within an \emph{Item} element would retrieve three matches. Using a dummy rule, we may first search for \emph{minimum price} elements and then search for \emph{formatted price} elements within that sub-tree.
\end{description}

This rule driven approach is highly intuitive and eases the mapping process from the services responses to the FAST facts.
It allows mapping basic types attributes, but also the creation of nested facts, such as having a fact \emph{Address} inside a fact \emph{Person}. Besides, it supports special operations, as attribute concatenation, in order to mediate with certain problems, for example, the fact Person has an attribute \emph{fullname} which is composed by the \emph{firstname} and \emph{lastname} elements of the response. This is done by setting \emph{lastname"', "`firstname} into the \emph{from} field of the transformation rule. Another special operation is the access to inner elements in the XML DOM. For example, an hypothetical attribute \emph{grandmother} could be filled using the rule \emph{mother.mother}. 

However, not every imaginable problem can be solved by a transformation rule. Mathematical operations, as converting temperatures from Fahrenheit into Celsius, or similar are not supported. However, complex cases as these may be solved by the use or creation of another kind of building block: the operator. More information about operators and the Data Mediation Tool can be found in~\cite{ambrus2011_mediation}.

Since FAST is storyboard oriented, the Service Wrapper Tool follows the storyboard idea as well. Any time, a change to a transformation rule is done, the transformation process is triggered and the resulting facts tree is directly shown. This process helps the user to deal with the slightly complex semantics of the transformation rules avoiding errors or mistakes. In addition, FAST is semantic-driven, therefore, the service wrapper designer retrieves the domain-specific types from the Catalogue server together with the structure of each type, i.e. a list of the properties or attributes of each concept. Therefore, the transformation rule editor is able to provide selection boxes for the target element of the rules. For a \emph{createObject} rule, this selection box shows the fact types available for that domain. For the \emph{fillAttributes} rules, the selection box shows the attributes of the fact type chosen in the parent rule. This rule ensures that the attributes of the generated fact match the type of the concept's properties defined in the ontology, and guarantees all mandatory attributes have a mapping rule.

% subsubsection translation_xml_into_facts (end)

% subsection interpreting_service_responses (end)

\subsection{Generating a Resource Adapter} % (fold)
\label{sub:generating_a_resource_adapter}

Once the wrapping of a service has been defined and tested in the Service Wrapper Tool, the user can invoke the creation of the Resource Adapter. This process triggers two actions: the generation of the Javascript code which encapsulates the calls to the Web service, and the creation of a new building block in the Catalogue, with its proper metadata. Thereby, the new Resource Adapter becomes available for the creation of new screens, and ready to be embedded in a gadget.

% subsection generating_a_resource_adapter (end)

% section restful_web_services_wrapper_tool (end)

\clearpage
\section{Similar Approaches and Related Work} % (fold)
\label{sec:related_work}

There is a number of related work that we have consider to use for service wrapping instead of building a Service Wrapper
Tool ourself. However, due to the special needs of the Gadget Development Process it turned out that we were not able 
to use an existing approach directly but we were only able to grab ideas from existing approaches and come up with our own implementation. 
As discussed, service wrapping requires three steps. First we have to define the connection between the desired service wrapper and the other building blocks of FAST. This is achieved by the definition of pre- and post-conditions in our tool. Since this is very FAST specific, finding an existing tool for this purpose did not work. However, this is a simple step anyhow requiring only limited implementation efforts. 

Second, we have to construct the request and to send it to the target service. There is already a number of REST clients 
for this purpose. There are even web based REST clients that may be used in a browser. We could easily have used such 
a standard REST client. However, we considered the user interfaces of these REST clients as too complicated for our
end users. In addition, we wanted an easy and simple connection to the pre- and post-conditions of the service wrapper. 
This required the integration of a template expansion mechanism into the REST client which was most easy to achieve 
with a new interface build by ourself. Again the effort for this step was limited and justified by the smooth integration into the overall tool. 

Third, we needed a data mediation step. This might have been achieved by e.g. XSLT tools. XSLT tools work on 
XML input and provide a template based generation of textual output. The problem with XSLT is a quite 
complex syntax which is not adequate for our end users. It would also have been difficult to provide our end users with direct feedback, as required by FAST's storyboard philosophy. Similarly, interactive help e.g. by selection boxes for target types and target attribute name would not have been possible, easily. Instead of XSLT we might also have used model based transformation languages like ATL (Atlas Transformation Language) or TGGs (Triple Graph Grammars). While these approaches work on a higher level of abstraction compared to XSLT, we still consider them too complicated for our end users. 
In addition, it would have been rather difficult to achieve an integrated interactive support as we have achieved in our 
own implementation. However, our translation rules are heavily influenced by TGGs which was a tremendous help 
for coming up with a simple and easy to use yet powerful approach. 

% section related_work (end)

\clearpage
\bibliographystyle{apalike}
\addcontentsline{toc}{section}{References}
\bibliography{fast_d4_3}

\clearpage
\doublespacing
\section*{Appendix A (Lists of Figures)}
\addcontentsline{toc}{section}{Appendix A (Lists of Figures)}

%\listoftables

\listoffigures


\end{document}
